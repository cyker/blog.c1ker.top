{"meta":{"title":"ciker","subtitle":"0hex","description":"Ciker's Blog.","author":"Ciker","url":"https://blog.c1ker.top"},"pages":[{"title":"","date":"2019-07-26T15:28:25.154Z","updated":"2019-07-26T15:28:25.154Z","comments":true,"path":"about/index.html","permalink":"https://blog.c1ker.top/about/index.html","excerpt":"","text":"title:about date:2017-02-14 06:06:06"},{"title":"SSTI 从零到EXP学习","date":"2019-08-20T03:42:03.000Z","updated":"2019-08-20T03:42:03.092Z","comments":true,"path":"SSTI-从零到EXP学习.html","permalink":"https://blog.c1ker.top/SSTI-从零到EXP学习.html","excerpt":"","text":""},{"title":"银联系统AWD WRITE UP","date":"2019-08-20T03:25:17.000Z","updated":"2019-08-20T03:27:52.196Z","comments":true,"path":"银联系统AWD-WRITE-UP（一）.html","permalink":"https://blog.c1ker.top/银联系统AWD-WRITE-UP（一）.html","excerpt":"","text":""}],"posts":[{"title":"HFish 蜜罐使用心得","slug":"HFish-蜜罐使用心得","date":"2019-11-15T08:10:04.000Z","updated":"2020-01-04T13:35:15.236Z","comments":true,"path":"2019/11/15/HFish-蜜罐使用心得/","link":"","permalink":"https://blog.c1ker.top/2019/11/15/HFish-蜜罐使用心得/","excerpt":"","text":"(本篇首发于 https://www.freebuf.com/vuls/220646.html) 最近搭建各种蜜罐测试，这篇文章主要分享 HFish V0.4 使用过程中的一些心得。 部署单节点部署单点部署官方文档介绍已经很全面了，不过windows 家庭版docker版部署有点坑需要注意的。 家庭版是不能直接安装docker，需要安装docker tool box ，原理是开启vbox 的linux虚拟机，然后在linux虚拟机里面安装docker，所以，在启用docker容器的时候，如果指定 -p 127.0.0.1:22:22 物理机是无法访问蜜罐，只能把容器的端口映射到0.0.0.0的地址上，物理机才可以访问。 eg: 1docker run -d -p 2222:22 -p 23:23 -p 9001:9001 -e USERNAME=god -e PASSWORD=123456 --name hfish imdevops/hfish:latest 然后进入linux虚拟机里面，查看虚拟机具体的ip地址 成功访问 分布式部署为了能尽可能全的收集全球攻击数据，这次计划采用分布式部署方式。使用vps供应商为 vultr ，IDC机房分布如下图 列表中有9个国家，ubuntu 系统最低配置每个月5美元，每个国家一台vps deploy 也没多少钱。这边有个注意点就是，在deploy时候，可以直接添加自己的ssh key，这样后面管理vps也很方便，因为我忘了我的ssh key 的密码了，就直接用账户密码管理。vps过多，管理起来挺麻烦的，这里我使用python3 的 paramiko 自动化一键配置，主要代码如下： 初始化服务器，并安装docker.io ： 启动 docker 容器： 官方分布式部署命令会少些端口，可以根据 config.ini 端口自行增删 这边还有一些需要注意的地方，国内访问国外服务器，可能会丢包，最好是在其中一台vps上面执行初始化脚本 运行完后，查看主节点，成功接收到数据 攻击数据分析分布式蜜罐部署了几天后，接下来是对捕获的数据进行分析了，下面主要以 SSH 蜜罐攻击行为为例。各位大佬也可以从附件里下载数据库自行分析。往后如果有能力，会定期提供蜜罐捕获数给各位。 攻击字典统计先来看下数据库 hfish_info 表结构及数据： 可以看到数据库用 &amp;&amp; 替换换行符，保存在数据库中，接下来可以写个统计攻击字典脚本。以下为关键部分示例代码： 123456def __init__(self): self.hfish_db = './file/hfish.db' self.hfish_split = '&amp;&amp;' self.sql = sqlite3.connect(self.hfish_db) #这里需要注意一下，测试时候发现，有些字符无法用utf-8解码，所以得用bytes self.sql.text_factory = bytes 搜索 sqlite 数据库中所有 ssh 攻击的类型 然后分割 &amp;&amp; ，把用户名密码分割开，并输出到文本里面 打印一下用户名及密码频次 取用户名及密码出现次数top10 12345# 按字典值反序排序,方法一user = sorted(user_pwd_dic['user'].items(), key=lambda x:x[1],reverse=True)# 按字典值反序排序,方法二password = list(user_pwd_dic['pwd'].items())password.sort(key=lambda x:x[1],reverse=True) 将结果打印 其实字典具有地域性，可以根据攻击字典地域性，配置下蜜罐，由于默认蜜罐账户密码均为root，不在常见外网爆破攻击字典里，所以后续很多攻击都无法进行。 字典地域性分析接下来分析一下各个国家的蜜罐收集到的字典差异，主要代码如下： 12345678910111213141516171819202122232425def RegionDic(self): agent_sql = \"select agent from hfish_info\" data = self.sql.execute(agent_sql).fetchall() agents = [] for agent in list(set(data)): agents.append(agent[0].decode('utf-8')) agents_dic = &#123;&#125; for agent in agents: agents_dic[agent] = &#123;&#125; data = self.sql.execute(dic_sql_tpl.format(agent)).fetchall() for d in data: if d[0] in agents_dic[agent].keys(): agents_dic[agent][d[0]] = agents_dic[agent][d[0]] + 1 else: agents_dic[agent][d[0]] = 1 agents_dic[agent] = sorted(agents_dic[agent].items(), key=lambda x:x[1],reverse=True) for agent in agents: print(agent) for i in range(5): #这里不直接用decode utf-8 是因为捕获到的一些字符无法用utf-8解码，这个在上一节连接数据库里面有提到。 print(\"%s\\t\\t%s\"%(str(agents_dic[agent][i][0]).replace(\"b'\",'').replace(\"'\",''), agents_dic[agent][i][1])) print() 得到的结果如下： 使用 pyecharts 生成图表， 123456789 bar = (Bar(options.InitOpts(width='1000px', height='500px')) .add_xaxis(u_p_dic) .add_yaxis(agent, u_p_count) .set_global_opts( title_opts=options.TitleOpts(title=(\"%s统计\"%agent)) ) ) tab.add(bar, agent)tab.render() 这里墙裂推荐直接看 pyecharts 官方文档，特别详细全面，不要搜CSDN里面的博客，不忍吐槽某些博文。 因为收集时间不长，且子节点和主节点通信莫名中断，此结果不具有普遍性 这里只是简单提取攻击字典，并没有做更深入分析，各位可以通过后面附件下载，自行分析。 后面会根据字典的地域性，在部署蜜罐的时候，修改特定的标致 蜜罐检测基于流量识别这里以攻击者在内网，且蜜罐是以分布式部署情况作为示例，拓扑图如下： 使用 tcpdump dump数据包，wireshark 打开，可以看到子节点和主节点之间的通信以明文传输，且有明显的特征 使用scapy 识别主节点和子节点的地址，主要代码如下 存在问题的代码在 /core/rpc/client/client.go 在内网渗透过程中，如果能发现部署的蜜罐，可以降低被发现可能性。 基于高交互蜜罐返回内容识别hfish 高交互式蜜罐是根据特征字符回显，匹配的规则有限，比如常见的读取 passwd 通常使用 cat /etc/passwd ，在SSH规则里有相应的规则 如果变形使用 1cat /etc/passwd &amp; 或者 1tail /etc/passwd 在正常的 vps 里面也是可以正常读取到 passwd 的内容， 但如果在蜜罐里面，则会显示异常，未修改配置的情况下是 test . 基于字符匹配的规则，总会有遗漏的地方，可以尝试变形的命令测试是否是hfish蜜罐。 高交互式蜜罐的配置文件在相应的 libs/蜜罐类型/ 下面，默认default 值在 libs/蜜罐类型/default.hf 。 基于管理端口返回内容识别这个很好理解了，如果返回包含管理页面特征字符就可以判断了，这里就直接给出 POC 了。 非授权接口获取信息问题代码在 /view/url.go 文件中 可以发现，这里连身份鉴别都没作，当获取到主机点ip及端口后，直接请求uri，就可以获取蜜罐捕获的信息，从而分析蜜罐位置。 验证POC： 12http://ip:port/api/v1/get/iphttp://ip:port/api/v1/get/fish_info 蜜罐攻击非授权攻击查看下主节点面板查询传输的数据包，用户认证是通过后，is_login 的值就是登陆用户，也就是说我们可以直接爆破这个用户，绕过登陆，直接设置后端各种参数，比如将报警参数置为空。 对应的问题源码在 /view/login/view.go 里 更新报警邮件的具体配置参数在 /view/setting/view.go 里面，禁止报警 poc 就不给出了，可自行查看对应参数。 存储型XSS这个漏洞是某位不愿提供ID大佬提醒的😏。 因为这漏洞是后台展示的原因，所以任何一个蜜罐都可以触发这个漏洞，这里以 ssh 蜜罐演示。 使用如下payload连接 1ssh ^&lt;script^&gt;alert^(1234^)^&lt;^/script^&gt;@192.168.99.101 -p 2222 我使用的是window系统，需要用 ^ 转义特殊字符 提交之后，返回 上钩列表 ，点击查看详情，可以看到成功执行xss。 特性化配置这里以攻击字典地域性特点及蜜罐检测中的交互式返回内容缺陷，特性化配置蜜罐。 根据地域，特性化蜜罐配置将用户名、密码修改为统计的字典出现频率最高的值。 123# 替换密码和用户名set_user_tpl = 'sed -i \"s/\\\\\"account\\\\\": \\\\\"root\\\\\"/\\\\\"account\\\\\": \\\\\"&#123;&#125;\\\\\"/g\" %s'%ssh_conf_pathset_pwd_tpl = 'sed -i \"s/\\\\\"password\\\\\": \\\\\"root\\\\\"/\\\\\"password\\\\\": \\\\\"&#123;&#125;\\\\\"/g\" %s'%ssh_conf_path 高交互式蜜罐默认返回修改咱们用一台Ubuntu 的vps测试一下，未知的命令返回： 也就是说，我们可以把默认返回修改为”command not found”的话，可以稍微改善下返回结果。 1set_default_tpl = 'sed -i \"s/test/: command not found/g\" %s'%ssh_default_path 致谢感谢三斤大佬解惑。 HFish 是一款非常不错的高交互式蜜罐，可扩展性好，可以帮忙点击一下 start，支持一下国产蜜罐。 HFish github HFish document 附件 sqlite数据库 HFish数据库github地址 攻击用户名字典 攻击密码字典 地域字典统计图表","categories":[{"name":"蜜罐","slug":"蜜罐","permalink":"https://blog.c1ker.top/categories/蜜罐/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://blog.c1ker.top/tags/网络/"},{"name":"蜜罐","slug":"蜜罐","permalink":"https://blog.c1ker.top/tags/蜜罐/"}],"keywords":[{"name":"蜜罐","slug":"蜜罐","permalink":"https://blog.c1ker.top/categories/蜜罐/"}]},{"title":"雪碧图爬虫","slug":"雪碧图爬虫","date":"2019-07-29T14:24:35.000Z","updated":"2020-01-04T13:35:38.809Z","comments":true,"path":"2019/07/29/雪碧图爬虫/","link":"","permalink":"https://blog.c1ker.top/2019/07/29/雪碧图爬虫/","excerpt":"","text":"看到群里讨论了一道爬虫题目，题目链接如下:雪碧图爬虫 题目 题意是爬取这一千页的数字并计算出这些数字的总和。 分析先来分析一下页面的源码（第一页的源码可以通过附件下载). 可以看出每个数字对应的 class 为至少七位的字符串，并且每次访问得到的值都不一样，从这里可以推断出，基本不可能通过抓取每个字符串的值去匹配每个数字。 再来看下CSS 图像: 格式化后成如下： 大概分为3部分，第一部分是ID对应切图的坐标，第二部分是高度及大小信息，第三部分是雪碧图原图。将雪碧图解码还原成图片如下： 解题根据以上信息，这道题的思路就很清楚了。 我们把图片里面的数字进行分割，切图偏移小于等于数字最左的像素值，现在只需要计算出每个数字左右两边的坐标即可，图像分割主要代码如下： 1234567891011split_num = []for x in range(0, width): check_flag = False for y in range(0, height): pix_data = img.getpixel((x,y)) if not (pix_data[0] &gt; 250 and pix_data[1] &gt; 250 and pix_data[2] &gt; 250): check_flag = True break if is_sign ^ check_flag: split_num.append(int(x)) is_sign = not is_sign （这边白色区域判定使用 250 是因为防止有些图片色泽不清，可能引起误判，实际应该使用 255 ） 测试数字边界识别结果如下： 然后接下来测试一下第一页识别的数值对不对，主要代码如下： 12345678910111213141516171819202122232425image_data = BytesIO(base64.b64decode(image_base64))img = Image.open(image_data)width = img.size[0]height = img.size[1]is_sign = Falsesplit_num = []for x in range(0, width): check_flag = False for y in range(0, height): pix_data = img.getpixel((x,y)) if not (pix_data[0] &gt; 250 and pix_data[1] &gt; 250 and pix_data[2] &gt; 250): check_flag = True break if is_sign ^ check_flag: split_num.append(int(x)) is_sign = not is_signsum_num = 0for block in block_arr: rt_str = '' for num_str in block: for i in range(0, len(split_num)): if int(self.position_dic[num_str]) &lt; split_num[i]: rt_str = rt_str + str(int(i/2)) break 运行结果: 接下来就是遍历一千页的事情了。题目出得还是比较简单的，要是图片中的数字是乱序，就很麻烦了。 附件 第一页源码 python源码","categories":[{"name":"雪碧图","slug":"雪碧图","permalink":"https://blog.c1ker.top/categories/雪碧图/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://blog.c1ker.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://blog.c1ker.top/tags/python/"}],"keywords":[{"name":"雪碧图","slug":"雪碧图","permalink":"https://blog.c1ker.top/categories/雪碧图/"}]},{"title":"Hello World","slug":"hello-wolrd","date":"2015-12-31T15:59:59.000Z","updated":"2019-07-29T15:40:23.176Z","comments":true,"path":"2015/12/31/hello-wolrd/","link":"","permalink":"https://blog.c1ker.top/2015/12/31/hello-wolrd/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo博客折腾","slug":"hexo博客折腾","permalink":"https://blog.c1ker.top/categories/hexo博客折腾/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.c1ker.top/tags/hexo/"}],"keywords":[{"name":"hexo博客折腾","slug":"hexo博客折腾","permalink":"https://blog.c1ker.top/categories/hexo博客折腾/"}]}]}